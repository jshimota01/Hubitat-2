/**
 *  NUT UPS Driver for Hubitat
 *  Michael Ritchie (@ritchierich)
 * 
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 */

metadata {
	definition (name: "NUT UPS Device", namespace: "mlritchie", author: "Michael Ritchie") {
		capability "Initialize"
		capability "Telnet"
		capability "Refresh"
		capability "PowerSource"
		capability "VoltageMeasurement"		
		capability "Battery"
	}
	
	attribute "battery'", "String"
	attribute "deviceAlarm", "String"
	attribute "batteryRuntime", "String"
	attribute "upsStatus", "String"

	preferences {
        input name: "nutServerHost", type: "text", description: "IP or hostname of NUT server", title: "NUT server hostname"
        input name: "nutServerPort", type: "number", description: "Port number of NUT server", title: "NUT server port number", defaultValue: 3493, range: "1..65535"
        //input name: "nutReconnectDelay", type: "number", description: "Network reconnect delay", title: "Number of seconds to wait before initiating reconnect in case the connection goes down for whatever reason", defaultValue: 10, range: "1..600"
        input name: "nutPollingInterval", type: "number", description: "Polling interval", title: "Polling interval", defaultValue: 10, range: "1..600"
    }
}

def installed(){
	initialize()
}

def updated(){
	unschedule()
	telnetClose()
	
	// In case preferences change, update the parent application
	parent.updateSetting("nutServerHost",[value:"${nutServerHost}",type:"text"])
	parent.updateSetting("nutServerPort",[value:"${nutServerPort}",type:"number"])
	parent.updateSetting("nutPollingInterval",[value:"${nutPollingInterval}",type:"number"])
	
	initialize()
}

def initialize(){
	state.remove("batteryDate")
	state.upsData = [:]
	state.upsUpdates = [:]
	state.lastPollTime = ""
	
	refresh()
}

def refresh() {
	telnetConnect([termChars:[10]], nutServerHost, nutServerPort.toInteger(), null, null)
	//pauseExecution(1000)
	if (!state.upsName) {
		sendCommand("LIST UPS")
		runIn(nutPollingInterval, refresh)
	}
	if (state.upsName) {
		sendCommand("LIST VAR ${state.upsName}")
		runIn(nutPollingInterval, refresh)
	}
}

def parse(String message) {
	parent.logDebug "Received: ${message}"
	
	String[] msg = message.split("\"?( |\$)(?=(([^\"]*\"){2})*[^\"]*\$)\"?")
	if (msg[0] == "UPS") {
		state.upsName = msg[1]
		refresh()
	} else if (message == "BEGIN LIST VAR " + state.upsName) {
		// Do nothinhg
	} else if (msg[0] == "VAR") {
		parseValues(msg.drop(2))
	} else if (message == "END LIST VAR " + state.upsName) {
		def nowDateTime = new java.text.SimpleDateFormat("MM/dd hh:mm a")
		nowDateTime.setTimeZone(location.timeZone)
		nowDateTime = nowDateTime.format(new Date()).toString()
		state.lastPollTime = nowDateTime
		parent.logDebug "nowDateTime ${nowDateTime}, state.lastPollTime ${state.lastPollTime}"
				
		if (state.upsUpdates.size() > 0) {
			createEvents(state.upsUpdates)
		}
	}
}

def parseValues(String[] msg) {
	def result = []
	def key = msg[0]
	def value = msg.length > 1 ? msg[1] : null
	
	// If no values have changed stop parsing to minimize logging
	if (state.upsData.containsKey(key) && state.upsData.get(key) == value) {
		//parent.logDebug "Value same"
		return
	} else {
		parent.logDebug "Value changed key: ${key}, from: ${state.upsData.get(key)}, to: ${value}"
		state.upsData["${key}"] = value
		state.upsUpdates["${key}"] = value
	}
}

def createEvents(upsUpdates) {
	def result = []
	upsUpdates.each{ key, value ->
		parent.logDebug "createEvents - key: ${key}, value: ${value}"

		switch (key) {
			case "battery.charge":
				if (device.currentValue("battery") != value.toInteger()) {
					result << createEvent(
						name: 'battery',
						value: value,
						unit: "%",
						descriptionText: "Battery is at ${value}%",
						displayed: true,
						isStateChange: true
					)
				}
				break;
			case "battery.mfr.date":
				state.batteryDate = value
				break;
			case "battery.runtime":
				def runtime = "mains"
				if (device.currentValue("powerSource") != "mains" && device.currentValue("batteryRuntime") == "mains") {
					runtime = (Integer.parseInt(value) / 60) + " minutes"
				}
				if (device.currentValue("batteryRuntime") != runtime) {
					result << createEvent(
						name: 'batteryRuntime',
						value: runtime,
						descriptionText: "Remaining runtime is ${runtime}",
						displayed: false,
						isStateChange: false
					)
				}
				break;
			case "ups.alarm":
				if (device.currentValue("deviceAlarm") != value) {
					result << createEvent(
						name: 'deviceAlarm',
						value: value,
						descriptionText: "Device alarm is ${value}",
						displayed: true,
						isStateChange: true
					)
				}
				break;
			case "ups.status":
				def statuses = value.split(" ")
				def powerSource = "unknown"
				if (statuses.contains('OL')) {
					powerSource = "mains"
				} else if (statuses.contains('OB')) {
					powerSource = "battery"
				}
				
				if (device.currentValue("powerSource") != powerSource) {
					result << createEvent(
						name: 'powerSource',
						value: powerSource,
						descriptionText: "Power source is ${powerSource}",
						displayed: true,
						isStateChange: true
					)
				}

				if (device.currentValue("deviceAlarm") != "All Clear" && !statuses.contains('ALARM')) {
					parent.logDebug "Alarm no longer detected."
					result << createEvent(
						name: 'deviceAlarm',
						value: 'All Clear',
						descriptionText: "Alarm removed.",
						displayed: true,
						isStateChange: true
					)
				}

				def statusCodeMap = [
					'OL': 'Online',
					'OB': 'On Battery',
					'LB': 'Low Battery',
					'HB': 'High Battery',
					'RB': 'Battery Needs Replaced',
					'CHRG': 'Battery Charging',
					'DISCHRG': 'Battery Discharging',
					'BYPASS': 'Bypass Active',
					'CAL': 'Runtime Calibration',
					'OFF': 'Offline',
					'OVER': 'Overloaded',
					'TRIM': 'Trimming Voltage',
					'BOOST': 'Boosting Voltage',
					'FSD': 'Forced Shutdown',
					'ALARM': 'Alarm'
				]

				String statusText = statuses?.collect { statusCodeMap[it] }.join(", ")
				if (device.currentValue("upsStatus") != statusText) {
					result << createEvent(
						name: 'upsStatus',
						value: statusText,
						descriptionText: "Device status is ${statusText}",
						displayed: true,
						isStateChange: true
					)
				}
				break;
		}
	}
	
	state.upsUpdates = [:]
	return result
}

def telnetStatus(String status) {
	log.error("telnetStatus: ${status}")
	//unschedule()
	//runIn(nutReconnectDelay.toInteger(), connectToServer)
}

def sendCommand(cmd) {
	parent.logDebug "sendCommand - Sending ${cmd}"
	return sendHubCommand(new hubitat.device.HubAction("${cmd}", hubitat.device.Protocol.TELNET))
}
